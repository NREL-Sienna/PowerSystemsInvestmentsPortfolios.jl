# This file was generated by the Julia OpenAPI Code Generator
# Do not modify this file directly. Modify the OpenAPI specification instead.


@doc raw"""SupplyTechnology

    SupplyTechnology(;
        base_power=nothing,
        heat_rate_mmbtu_per_mwh=nothing,
        zone=nothing,
        prime_mover_type=nothing,
        minimum_required_capacity=nothing,
        cofire_level_min=nothing,
        capital_costs=nothing,
        outage_factor=nothing,
        rsv_cost=nothing,
        cofire_start_max=nothing,
        gen_ID=nothing,
        available=nothing,
        co2=nothing,
        name=nothing,
        cofire_start_min=nothing,
        ramp_dn_percentage=nothing,
        down_time=nothing,
        initial_capacity=nothing,
        start_fuel_mmbtu_per_mw=nothing,
        operation_costs=nothing,
        rsv_max=nothing,
        fuel=nothing,
        power_systems_type=nothing,
        cofire_level_max=nothing,
        internal=nothing,
        ext=nothing,
        balancing_topology=nothing,
        maximum_capacity=nothing,
        cluster=nothing,
        ramp_up_percentage=nothing,
        unit_size=nothing,
        reg_cost=nothing,
        min_generation_percentage=nothing,
        start_cost_per_mw=nothing,
        reg_max=nothing,
        up_time=nothing,
    )

    - base_power::Float64 : Base power
    - heat_rate_mmbtu_per_mwh::Union{Float64PSYValueCurveDict{ThermalFuelsPSYValueCurve}} : Heat rate of generator, MMBTU/MWh
    - zone::Union{NothingInt64Zone} : Zone where tech operates in
    - prime_mover_type::PrimeMovers : Prime mover for generator
    - minimum_required_capacity::Float64 : Minimum required capacity for a technology
    - cofire_level_min::Union{NothingDict{ThermalFuelsFloat64}} : Minimum blending level of each fuel during normal generation process for multi-fuel generator
    - capital_costs::PSYValueCurve : Capital costs for investing in a technology.
    - outage_factor::Float64 : Derating factor to account for planned or forced outages of a technology
    - rsv_cost::Float64 : Cost of providing upwards spinning or contingency reserves
    - cofire_start_max::Union{NothingDict{ThermalFuelsFloat64}} : Maximum blending level of each fuel during start-up process for multi-fuel generator
    - gen_ID::Int64 : ID for individual generator
    - available::Bool : identifies whether the technology is available
    - co2::Union{Float64Dict{StringFloat64}Dict{ThermalFuelsFloat64}} : Carbon Intensity of fuel
    - name::String : The technology name
    - cofire_start_min::Union{NothingDict{ThermalFuelsFloat64}} : Minimum blending level of each fuel during start-up process for multi-fuel generator
    - ramp_dn_percentage::Float64 : Maximum decrease in output between operation periods. Fraction of total capacity
    - down_time::Float64 : Minimum amount of time a resource has to remain in the shutdown state.
    - initial_capacity::Float64 : Pre-existing capacity for a technology
    - start_fuel_mmbtu_per_mw::Float64 : Startup fuel use per MW of nameplate capacity of each generator (MMBtu/MW per start)
    - operation_costs::PSYOperationalCost : Fixed and variable O&amp;M costs for a technology
    - rsv_max::Float64 : Fraction of nameplate capacity that can committed to provided upwards spinning or contingency reserves.
    - fuel::Union{StringThermalFuelsVector{ThermalFuels}Vector{String}} : Fuel type according to IEA
    - power_systems_type::String : maps to a valid PowerSystems.jl for PCM modeling
    - cofire_level_max::Union{NothingDict{ThermalFuelsFloat64}} : Maximum blending level of each fuel during normal generation process for multi-fuel generator
    - internal::InfrastructureSystemsInternal : Internal field
    - ext::Dict : Option for providing additional data
    - balancing_topology::String : Set of balancing nodes
    - maximum_capacity::Float64 : Maximum allowable installed capacity for a technology
    - cluster::Int64 : Number of the cluster when representing multiple clusters of a given technology in a given region.
    - ramp_up_percentage::Float64 : Maximum increase in output between operation periods. Fraction of total capacity
    - unit_size::Float64 : Used for discrete investment decisions. Size of each unit being built (MW)
    - reg_cost::Float64 : Cost of providing regulation reserves 
    - min_generation_percentage::Float64 : Minimum generation as a fraction of total capacity
    - start_cost_per_mw::Float64 : Cost per MW of nameplate capacity to start a generator (/MW per start).
    - reg_max::Float64 : Fraction of nameplate capacity that can committed to provided regulation reserves
    - up_time::Float64 : Minimum amount of time a resource has to stay in the committed state.
"""
Base.@kwdef mutable struct SupplyTechnology <: OpenAPI.APIModel
    base_power::Union{Nothing, Float64} = nothing
    heat_rate_mmbtu_per_mwh = nothing # spec type: Union{ Nothing, Union{Float64PSYValueCurveDict{ThermalFuelsPSYValueCurve}} }
    zone = nothing # spec type: Union{ Nothing, Union{NothingInt64Zone} }
    prime_mover_type = nothing # spec type: Union{ Nothing, PrimeMovers }
    minimum_required_capacity::Union{Nothing, Float64} = nothing
    cofire_level_min = nothing # spec type: Union{ Nothing, Union{NothingDict{ThermalFuelsFloat64}} }
    capital_costs = nothing # spec type: Union{ Nothing, PSYValueCurve }
    outage_factor::Union{Nothing, Float64} = nothing
    rsv_cost::Union{Nothing, Float64} = nothing
    cofire_start_max = nothing # spec type: Union{ Nothing, Union{NothingDict{ThermalFuelsFloat64}} }
    gen_ID::Union{Nothing, Int64} = nothing
    available::Union{Nothing, Bool} = nothing
    co2 = nothing # spec type: Union{ Nothing, Union{Float64Dict{StringFloat64}Dict{ThermalFuelsFloat64}} }
    name::Union{Nothing, String} = nothing
    cofire_start_min = nothing # spec type: Union{ Nothing, Union{NothingDict{ThermalFuelsFloat64}} }
    ramp_dn_percentage::Union{Nothing, Float64} = nothing
    down_time::Union{Nothing, Float64} = nothing
    initial_capacity::Union{Nothing, Float64} = nothing
    start_fuel_mmbtu_per_mw::Union{Nothing, Float64} = nothing
    operation_costs = nothing # spec type: Union{ Nothing, PSYOperationalCost }
    rsv_max::Union{Nothing, Float64} = nothing
    fuel = nothing # spec type: Union{ Nothing, Union{StringThermalFuelsVector{ThermalFuels}Vector{String}} }
    power_systems_type::Union{Nothing, String} = nothing
    cofire_level_max = nothing # spec type: Union{ Nothing, Union{NothingDict{ThermalFuelsFloat64}} }
    internal = nothing # spec type: Union{ Nothing, InfrastructureSystemsInternal }
    ext::Union{Nothing, Dict} = nothing
    balancing_topology::Union{Nothing, String} = nothing
    maximum_capacity::Union{Nothing, Float64} = nothing
    cluster::Union{Nothing, Int64} = nothing
    ramp_up_percentage::Union{Nothing, Float64} = nothing
    unit_size::Union{Nothing, Float64} = nothing
    reg_cost::Union{Nothing, Float64} = nothing
    min_generation_percentage::Union{Nothing, Float64} = nothing
    start_cost_per_mw::Union{Nothing, Float64} = nothing
    reg_max::Union{Nothing, Float64} = nothing
    up_time::Union{Nothing, Float64} = nothing

    function SupplyTechnology(base_power, heat_rate_mmbtu_per_mwh, zone, prime_mover_type, minimum_required_capacity, cofire_level_min, capital_costs, outage_factor, rsv_cost, cofire_start_max, gen_ID, available, co2, name, cofire_start_min, ramp_dn_percentage, down_time, initial_capacity, start_fuel_mmbtu_per_mw, operation_costs, rsv_max, fuel, power_systems_type, cofire_level_max, internal, ext, balancing_topology, maximum_capacity, cluster, ramp_up_percentage, unit_size, reg_cost, min_generation_percentage, start_cost_per_mw, reg_max, up_time, )
        OpenAPI.validate_property(SupplyTechnology, Symbol("base_power"), base_power)
        OpenAPI.validate_property(SupplyTechnology, Symbol("heat_rate_mmbtu_per_mwh"), heat_rate_mmbtu_per_mwh)
        OpenAPI.validate_property(SupplyTechnology, Symbol("zone"), zone)
        OpenAPI.validate_property(SupplyTechnology, Symbol("prime_mover_type"), prime_mover_type)
        OpenAPI.validate_property(SupplyTechnology, Symbol("minimum_required_capacity"), minimum_required_capacity)
        OpenAPI.validate_property(SupplyTechnology, Symbol("cofire_level_min"), cofire_level_min)
        OpenAPI.validate_property(SupplyTechnology, Symbol("capital_costs"), capital_costs)
        OpenAPI.validate_property(SupplyTechnology, Symbol("outage_factor"), outage_factor)
        OpenAPI.validate_property(SupplyTechnology, Symbol("rsv_cost"), rsv_cost)
        OpenAPI.validate_property(SupplyTechnology, Symbol("cofire_start_max"), cofire_start_max)
        OpenAPI.validate_property(SupplyTechnology, Symbol("gen_ID"), gen_ID)
        OpenAPI.validate_property(SupplyTechnology, Symbol("available"), available)
        OpenAPI.validate_property(SupplyTechnology, Symbol("co2"), co2)
        OpenAPI.validate_property(SupplyTechnology, Symbol("name"), name)
        OpenAPI.validate_property(SupplyTechnology, Symbol("cofire_start_min"), cofire_start_min)
        OpenAPI.validate_property(SupplyTechnology, Symbol("ramp_dn_percentage"), ramp_dn_percentage)
        OpenAPI.validate_property(SupplyTechnology, Symbol("down_time"), down_time)
        OpenAPI.validate_property(SupplyTechnology, Symbol("initial_capacity"), initial_capacity)
        OpenAPI.validate_property(SupplyTechnology, Symbol("start_fuel_mmbtu_per_mw"), start_fuel_mmbtu_per_mw)
        OpenAPI.validate_property(SupplyTechnology, Symbol("operation_costs"), operation_costs)
        OpenAPI.validate_property(SupplyTechnology, Symbol("rsv_max"), rsv_max)
        OpenAPI.validate_property(SupplyTechnology, Symbol("fuel"), fuel)
        OpenAPI.validate_property(SupplyTechnology, Symbol("power_systems_type"), power_systems_type)
        OpenAPI.validate_property(SupplyTechnology, Symbol("cofire_level_max"), cofire_level_max)
        OpenAPI.validate_property(SupplyTechnology, Symbol("internal"), internal)
        OpenAPI.validate_property(SupplyTechnology, Symbol("ext"), ext)
        OpenAPI.validate_property(SupplyTechnology, Symbol("balancing_topology"), balancing_topology)
        OpenAPI.validate_property(SupplyTechnology, Symbol("maximum_capacity"), maximum_capacity)
        OpenAPI.validate_property(SupplyTechnology, Symbol("cluster"), cluster)
        OpenAPI.validate_property(SupplyTechnology, Symbol("ramp_up_percentage"), ramp_up_percentage)
        OpenAPI.validate_property(SupplyTechnology, Symbol("unit_size"), unit_size)
        OpenAPI.validate_property(SupplyTechnology, Symbol("reg_cost"), reg_cost)
        OpenAPI.validate_property(SupplyTechnology, Symbol("min_generation_percentage"), min_generation_percentage)
        OpenAPI.validate_property(SupplyTechnology, Symbol("start_cost_per_mw"), start_cost_per_mw)
        OpenAPI.validate_property(SupplyTechnology, Symbol("reg_max"), reg_max)
        OpenAPI.validate_property(SupplyTechnology, Symbol("up_time"), up_time)
        return new(base_power, heat_rate_mmbtu_per_mwh, zone, prime_mover_type, minimum_required_capacity, cofire_level_min, capital_costs, outage_factor, rsv_cost, cofire_start_max, gen_ID, available, co2, name, cofire_start_min, ramp_dn_percentage, down_time, initial_capacity, start_fuel_mmbtu_per_mw, operation_costs, rsv_max, fuel, power_systems_type, cofire_level_max, internal, ext, balancing_topology, maximum_capacity, cluster, ramp_up_percentage, unit_size, reg_cost, min_generation_percentage, start_cost_per_mw, reg_max, up_time, )
    end
end # type SupplyTechnology

const _property_types_SupplyTechnology = Dict{Symbol,String}(Symbol("base_power")=>"Float64", Symbol("heat_rate_mmbtu_per_mwh")=>"Union{Float64PSYValueCurveDict{ThermalFuelsPSYValueCurve}}", Symbol("zone")=>"Union{NothingInt64Zone}", Symbol("prime_mover_type")=>"PrimeMovers", Symbol("minimum_required_capacity")=>"Float64", Symbol("cofire_level_min")=>"Union{NothingDict{ThermalFuelsFloat64}}", Symbol("capital_costs")=>"PSYValueCurve", Symbol("outage_factor")=>"Float64", Symbol("rsv_cost")=>"Float64", Symbol("cofire_start_max")=>"Union{NothingDict{ThermalFuelsFloat64}}", Symbol("gen_ID")=>"Int64", Symbol("available")=>"Bool", Symbol("co2")=>"Union{Float64Dict{StringFloat64}Dict{ThermalFuelsFloat64}}", Symbol("name")=>"String", Symbol("cofire_start_min")=>"Union{NothingDict{ThermalFuelsFloat64}}", Symbol("ramp_dn_percentage")=>"Float64", Symbol("down_time")=>"Float64", Symbol("initial_capacity")=>"Float64", Symbol("start_fuel_mmbtu_per_mw")=>"Float64", Symbol("operation_costs")=>"PSYOperationalCost", Symbol("rsv_max")=>"Float64", Symbol("fuel")=>"Union{StringThermalFuelsVector{ThermalFuels}Vector{String}}", Symbol("power_systems_type")=>"String", Symbol("cofire_level_max")=>"Union{NothingDict{ThermalFuelsFloat64}}", Symbol("internal")=>"InfrastructureSystemsInternal", Symbol("ext")=>"Dict", Symbol("balancing_topology")=>"String", Symbol("maximum_capacity")=>"Float64", Symbol("cluster")=>"Int64", Symbol("ramp_up_percentage")=>"Float64", Symbol("unit_size")=>"Float64", Symbol("reg_cost")=>"Float64", Symbol("min_generation_percentage")=>"Float64", Symbol("start_cost_per_mw")=>"Float64", Symbol("reg_max")=>"Float64", Symbol("up_time")=>"Float64", )
OpenAPI.property_type(::Type{ SupplyTechnology }, name::Symbol) = Union{Nothing,eval(Base.Meta.parse(_property_types_SupplyTechnology[name]))}

function check_required(o::SupplyTechnology)
    o.available === nothing && (return false)
    o.name === nothing && (return false)
    o.power_systems_type === nothing && (return false)
    true
end

function OpenAPI.validate_property(::Type{ SupplyTechnology }, name::Symbol, val)
    if name === Symbol("prime_mover_type")
        OpenAPI.validate_param(name, "SupplyTechnology", :enum, val, [BT, CA, CC, CS, CT, FC, GT, HA, HB, HK, HY, IC, OT, ST, PVe, WT, WS])
    end
    if name === Symbol("fuel")
        OpenAPI.validate_param(name, "SupplyTechnology", :enum, val, [COAL, WASTE_COAL, DISTILLATE_FUEL_OIL, WASTE_OIL, PETROLEUM_COKE, RESIDUAL_FUEL_OIL, NATURAL_GAS, OTHER_GAS, NUCLEAR, AG_BIPRODUCT, MUNICIPAL_WASTE, WOOD_WASTE, GEOTHERMAL, OTHER])
    end
end
