# This file was generated by the Julia OpenAPI Code Generator
# Do not modify this file directly. Modify the OpenAPI specification instead.


@doc raw"""StorageTechnology

    StorageTechnology(;
        base_power=nothing,
        prime_mover_type=nothing,
        lifetime=nothing,
        min_capacity_energy=nothing,
        available=nothing,
        name=nothing,
        storage_tech=nothing,
        capital_costs_power=nothing,
        max_duration=nothing,
        operations_costs_power=nothing,
        unit_size_power=nothing,
        id=nothing,
        losses=nothing,
        capital_costs_energy=nothing,
        financial_data=nothing,
        existing_capacity_power=nothing,
        power_systems_type=nothing,
        internal=nothing,
        min_capacity_power=nothing,
        max_capacity_power=nothing,
        balancing_topology=nothing,
        efficiency_out=nothing,
        region=nothing,
        ext=nothing,
        unit_size_energy=nothing,
        max_capacity_energy=nothing,
        efficiency_in=nothing,
        base_year=nothing,
        existing_capacity_energy=nothing,
        min_duration=nothing,
        operations_costs_energy=nothing,
    )

    - base_power::Float64 : Base power
    - prime_mover_type::PrimeMovers : Prime mover for generator
    - lifetime::Int : Maximum number of years a technology can be active once installed
    - min_capacity_energy::Float64 : Minimum required energy capacity for a storage technology
    - available::Bool : identifies whether the technology is available
    - name::String : The technology name
    - storage_tech::StorageTech : Storage Technology Type
    - capital_costs_power::PSYValueCurve : Capital costs for investing in a technology.
    - max_duration::Float64 : Maximum allowable durection for a storage technology
    - operations_costs_power::PSYOperationalCost : Fixed and variable O&amp;M costs for a technology
    - unit_size_power::Float64 : Used for discrete investment decisions. Size of each unit being built (MW)
    - id::Int64 : ID for individual generator
    - losses::Float64 : Power loss (pct per hour)
    - capital_costs_energy::PSYValueCurve : Capital costs for investing in a technology.
    - financial_data::TechnologyFinancialData : Struct containing relevant financial information for a technology
    - existing_capacity_power::Float64 : Pre-existing power capacity for a technology (MW)
    - power_systems_type::String : maps to a valid PowerSystems.jl for PCM modeling
    - internal::InfrastructureSystemsInternal : Internal field
    - min_capacity_power::Float64 : Minimum required power capacity for a storage technology
    - max_capacity_power::Float64 : Maximum allowable installed power capacity for a storage technology
    - balancing_topology::String : Set of balancing nodes
    - efficiency_out::Float64 : Efficiency of discharging storage
    - region::Union{NothingRegionVector{Region}} : Region
    - ext::Dict : Option for providing additional data
    - unit_size_energy::Float64 : Used for discrete investment decisions. Size of each unit being built (MW)
    - max_capacity_energy::Float64 : Maximum allowable installed energy capacity for a storage technology
    - efficiency_in::Float64 : Efficiency of charging storage
    - base_year::Int : Reference year for technology data
    - existing_capacity_energy::Float64 : Pre-existing energy capacity for a technology (MWh)
    - min_duration::Float64 : Minimum required durection for a storage technology
    - operations_costs_energy::PSYOperationalCost : Fixed and variable O&amp;M costs for a technology
"""
Base.@kwdef mutable struct StorageTechnology <: OpenAPI.APIModel
    base_power::Union{Nothing, Float64} = nothing
    prime_mover_type = nothing # spec type: Union{ Nothing, PrimeMovers }
    lifetime = nothing # spec type: Union{ Nothing, Int }
    min_capacity_energy::Union{Nothing, Float64} = nothing
    available::Union{Nothing, Bool} = nothing
    name::Union{Nothing, String} = nothing
    storage_tech = nothing # spec type: Union{ Nothing, StorageTech }
    capital_costs_power = nothing # spec type: Union{ Nothing, PSYValueCurve }
    max_duration::Union{Nothing, Float64} = nothing
    operations_costs_power = nothing # spec type: Union{ Nothing, PSYOperationalCost }
    unit_size_power::Union{Nothing, Float64} = nothing
    id::Union{Nothing, Int64} = nothing
    losses::Union{Nothing, Float64} = nothing
    capital_costs_energy = nothing # spec type: Union{ Nothing, PSYValueCurve }
    financial_data = nothing # spec type: Union{ Nothing, TechnologyFinancialData }
    existing_capacity_power::Union{Nothing, Float64} = nothing
    power_systems_type::Union{Nothing, String} = nothing
    internal = nothing # spec type: Union{ Nothing, InfrastructureSystemsInternal }
    min_capacity_power::Union{Nothing, Float64} = nothing
    max_capacity_power::Union{Nothing, Float64} = nothing
    balancing_topology::Union{Nothing, String} = nothing
    efficiency_out::Union{Nothing, Float64} = nothing
    region = nothing # spec type: Union{ Nothing, Union{NothingRegionVector{Region}} }
    ext::Union{Nothing, Dict} = nothing
    unit_size_energy::Union{Nothing, Float64} = nothing
    max_capacity_energy::Union{Nothing, Float64} = nothing
    efficiency_in::Union{Nothing, Float64} = nothing
    base_year = nothing # spec type: Union{ Nothing, Int }
    existing_capacity_energy::Union{Nothing, Float64} = nothing
    min_duration::Union{Nothing, Float64} = nothing
    operations_costs_energy = nothing # spec type: Union{ Nothing, PSYOperationalCost }

    function StorageTechnology(base_power, prime_mover_type, lifetime, min_capacity_energy, available, name, storage_tech, capital_costs_power, max_duration, operations_costs_power, unit_size_power, id, losses, capital_costs_energy, financial_data, existing_capacity_power, power_systems_type, internal, min_capacity_power, max_capacity_power, balancing_topology, efficiency_out, region, ext, unit_size_energy, max_capacity_energy, efficiency_in, base_year, existing_capacity_energy, min_duration, operations_costs_energy, )
        OpenAPI.validate_property(StorageTechnology, Symbol("base_power"), base_power)
        OpenAPI.validate_property(StorageTechnology, Symbol("prime_mover_type"), prime_mover_type)
        OpenAPI.validate_property(StorageTechnology, Symbol("lifetime"), lifetime)
        OpenAPI.validate_property(StorageTechnology, Symbol("min_capacity_energy"), min_capacity_energy)
        OpenAPI.validate_property(StorageTechnology, Symbol("available"), available)
        OpenAPI.validate_property(StorageTechnology, Symbol("name"), name)
        OpenAPI.validate_property(StorageTechnology, Symbol("storage_tech"), storage_tech)
        OpenAPI.validate_property(StorageTechnology, Symbol("capital_costs_power"), capital_costs_power)
        OpenAPI.validate_property(StorageTechnology, Symbol("max_duration"), max_duration)
        OpenAPI.validate_property(StorageTechnology, Symbol("operations_costs_power"), operations_costs_power)
        OpenAPI.validate_property(StorageTechnology, Symbol("unit_size_power"), unit_size_power)
        OpenAPI.validate_property(StorageTechnology, Symbol("id"), id)
        OpenAPI.validate_property(StorageTechnology, Symbol("losses"), losses)
        OpenAPI.validate_property(StorageTechnology, Symbol("capital_costs_energy"), capital_costs_energy)
        OpenAPI.validate_property(StorageTechnology, Symbol("financial_data"), financial_data)
        OpenAPI.validate_property(StorageTechnology, Symbol("existing_capacity_power"), existing_capacity_power)
        OpenAPI.validate_property(StorageTechnology, Symbol("power_systems_type"), power_systems_type)
        OpenAPI.validate_property(StorageTechnology, Symbol("internal"), internal)
        OpenAPI.validate_property(StorageTechnology, Symbol("min_capacity_power"), min_capacity_power)
        OpenAPI.validate_property(StorageTechnology, Symbol("max_capacity_power"), max_capacity_power)
        OpenAPI.validate_property(StorageTechnology, Symbol("balancing_topology"), balancing_topology)
        OpenAPI.validate_property(StorageTechnology, Symbol("efficiency_out"), efficiency_out)
        OpenAPI.validate_property(StorageTechnology, Symbol("region"), region)
        OpenAPI.validate_property(StorageTechnology, Symbol("ext"), ext)
        OpenAPI.validate_property(StorageTechnology, Symbol("unit_size_energy"), unit_size_energy)
        OpenAPI.validate_property(StorageTechnology, Symbol("max_capacity_energy"), max_capacity_energy)
        OpenAPI.validate_property(StorageTechnology, Symbol("efficiency_in"), efficiency_in)
        OpenAPI.validate_property(StorageTechnology, Symbol("base_year"), base_year)
        OpenAPI.validate_property(StorageTechnology, Symbol("existing_capacity_energy"), existing_capacity_energy)
        OpenAPI.validate_property(StorageTechnology, Symbol("min_duration"), min_duration)
        OpenAPI.validate_property(StorageTechnology, Symbol("operations_costs_energy"), operations_costs_energy)
        return new(base_power, prime_mover_type, lifetime, min_capacity_energy, available, name, storage_tech, capital_costs_power, max_duration, operations_costs_power, unit_size_power, id, losses, capital_costs_energy, financial_data, existing_capacity_power, power_systems_type, internal, min_capacity_power, max_capacity_power, balancing_topology, efficiency_out, region, ext, unit_size_energy, max_capacity_energy, efficiency_in, base_year, existing_capacity_energy, min_duration, operations_costs_energy, )
    end
end # type StorageTechnology

const _property_types_StorageTechnology = Dict{Symbol,String}(Symbol("base_power")=>"Float64", Symbol("prime_mover_type")=>"PrimeMovers", Symbol("lifetime")=>"Int", Symbol("min_capacity_energy")=>"Float64", Symbol("available")=>"Bool", Symbol("name")=>"String", Symbol("storage_tech")=>"StorageTech", Symbol("capital_costs_power")=>"PSYValueCurve", Symbol("max_duration")=>"Float64", Symbol("operations_costs_power")=>"PSYOperationalCost", Symbol("unit_size_power")=>"Float64", Symbol("id")=>"Int64", Symbol("losses")=>"Float64", Symbol("capital_costs_energy")=>"PSYValueCurve", Symbol("financial_data")=>"TechnologyFinancialData", Symbol("existing_capacity_power")=>"Float64", Symbol("power_systems_type")=>"String", Symbol("internal")=>"InfrastructureSystemsInternal", Symbol("min_capacity_power")=>"Float64", Symbol("max_capacity_power")=>"Float64", Symbol("balancing_topology")=>"String", Symbol("efficiency_out")=>"Float64", Symbol("region")=>"Union{NothingRegionVector{Region}}", Symbol("ext")=>"Dict", Symbol("unit_size_energy")=>"Float64", Symbol("max_capacity_energy")=>"Float64", Symbol("efficiency_in")=>"Float64", Symbol("base_year")=>"Int", Symbol("existing_capacity_energy")=>"Float64", Symbol("min_duration")=>"Float64", Symbol("operations_costs_energy")=>"PSYOperationalCost", )
OpenAPI.property_type(::Type{ StorageTechnology }, name::Symbol) = Union{Nothing,eval(Base.Meta.parse(_property_types_StorageTechnology[name]))}

function check_required(o::StorageTechnology)
    o.available === nothing && (return false)
    o.name === nothing && (return false)
    o.power_systems_type === nothing && (return false)
    true
end

function OpenAPI.validate_property(::Type{ StorageTechnology }, name::Symbol, val)
    if name === Symbol("prime_mover_type")
        OpenAPI.validate_param(name, "StorageTechnology", :enum, val, [PrimeMovers.BT, PrimeMovers.CA, PrimeMovers.CC, PrimeMovers.CS, PrimeMovers.CT, PrimeMovers.FC, PrimeMovers.GT, PrimeMovers.HA, PrimeMovers.HB, PrimeMovers.HK, PrimeMovers.HY, PrimeMovers.IC, PrimeMovers.OT, PrimeMovers.ST, PrimeMovers.PVe, PrimeMovers.WT, PrimeMovers.WS])
    end
    if name === Symbol("storage_tech")
        OpenAPI.validate_param(name, "StorageTechnology", :enum, val, [StorageTech.PTES, StorageTech.LIB, StorageTech.LAB, StorageTech.FLWB, StorageTech.SIB, StorageTech.ZIB, StorageTech.HGS, StorageTech.LAES, StorageTech.OTHER_CHEM, StorageTech.OTHER_MECH, StorageTech.OTHER_THERM])
    end
end
